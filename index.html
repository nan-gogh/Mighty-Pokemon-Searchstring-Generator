<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mächtiger Suchstring Generator</title>
  <link rel="icon" href="./mighty_mark_go.svg" type="image/svg+xml" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root{
  --color-bg-dark-teal: #12251d;
  --color-bg-charcoal: #0f1011;
  --color-lime-bright: #d5ff9a;
  --color-teal-primary: #61C497;
  --color-charcoal-dark: #1a1b1c;
  --color-border-subtle: rgba(255,255,255,0.03);
  --color-focus-blue: rgba(78, 144, 254, 0.12);
  --header-control-effective: clamp(min(140px, 95vw), 85vw, 300px);
  --radius: 999px;
  --transition-smooth: 520ms cubic-bezier(.2,0,.2,1);
  --transition-fast: 120ms ease;
  --font-display: 'Orbitron', Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  --font-mono: 'Space Grotesk', ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
  /* repeated glow colors */
  --glow-subtle: rgba(213,255,154,0.12);
  --glow-mid: rgba(97,196,151,0.06);
  --glow-strong: rgba(213,255,154,0.8);
  --glow-strong-teal: rgba(97,196,151,0.8);
  --lime-95: rgba(213,255,154,0.95);
  --lime-55: rgba(213,255,154,0.55);
  /* additional lime variants used in animations */
  --lime-06: rgba(213,255,154,0.06);
  --lime-08: rgba(213,255,154,0.08);
  --lime-10: rgba(213,255,154,0.10);
  --lime-14: rgba(213,255,154,0.14);
  --lime-16: rgba(213,255,154,0.16);
  --lime-40: rgba(213,255,154,0.40);
  --lime-60: rgba(213,255,154,0.60);
  --lime-100: rgba(213,255,154,1);
}

html{box-sizing:border-box}
*,*::before,*::after{box-sizing:inherit}

html,body{
  height:100%;
  margin:0;
  font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
}

body{
  background:var(--color-bg-dark-teal);
  color:var(--color-teal-primary);
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  position:relative;
  z-index:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  /* Use flex-start so when the content is taller than the viewport
     users can scroll to the very top. Previously centering prevented
     reaching the header image's top edge at extreme zoom. */
  justify-content:flex-start;
  min-height:100vh;
  /* preserve the original breathing room but add a larger top padding
     so short pages still visually sit away from the viewport top */
  padding:clamp(12px, 3vw, 28px);
  padding-top: clamp(28px, 10vh, 80px);
  box-sizing:border-box;
}

/* When the page content is shorter than the viewport, apply this class
   to vertically center the content. When content is taller, remove it so
   users can scroll to the top freely. Toggled via JS (updateBodyCentered). */
body.centered{
  justify-content: center;
  /* reduce top padding when truly centered to keep the visual balance */
  padding-top: clamp(12px, 6vh, 48px);
}

body::before{
  content: "";
  position:fixed;
  inset:0;
  background-image: url('./young_will.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  opacity: 0.15;
  pointer-events: none;
  z-index: 0;
  mix-blend-mode: overlay;
  -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0.0), rgba(0,0,0,1));
  mask-image: linear-gradient(to bottom, rgba(0,0,0,0.0), rgba(0,0,0,1));
}

body > *{position:relative;z-index:1}

header{
  background: transparent;
  color:var(--color-teal-primary); 
  padding:clamp(8px, 2.5vw, 18px) 0 clamp(4px, 1vw, 6px) 0;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:clamp(6px, 2vw, 10px);
  position:relative;
  width:100%;
  max-width:min(980px, 95vw);
}

.header-svg-container{
  position: relative;
  width: var(--header-control-effective);
  height: auto;
  /* lock an explicit aspect ratio so both SVG layers scale identically */
  aspect-ratio: 188.38 / 148.46;
  flex: 0 0 auto;
  max-width: 92vw;
  /* small upward nudge so the header image visually sits closer to the top */
  --header-y-offset: clamp(-12px, -3.5vh, -36px);
  transform: translateY(var(--header-y-offset));
}

/* Soft radial lime glow positioned behind the SVG layers but inside the container */
.header-svg-container::before{
  content: "";
  position: absolute;
  inset: 0;
  z-index: -1;
  pointer-events: none;
  border-radius: inherit;
    background: radial-gradient(circle at 50% 70%, var(--color-teal-primary) 0%, var(--color-teal-primary) 30%, var(--lime-16) 50%, transparent 60%);
  filter: blur(14px);
  transform: translateZ(0) scale(1.25);
  opacity: 0.95;
}

.header-crown, .header-energy{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  border-radius: 0;
  filter: drop-shadow(0 0 20px var(--color-lime-bright));
  transform-origin: center;
  transform-box: fill-box;
  will-change: transform, filter;
  /* default animation applied to the mark only; energy overrides below */
}

.header-crown{
  z-index: 10001;
  /* use percentage offsets so translations scale with the SVG/container size */
  --bob-offset: -6%;
  --svg-scale: 0.6;
  animation: img-bob 4s ease-in-out infinite, img-glow 3s ease-in-out infinite;
}

.header-energy{
      z-index: 0;
  opacity: 0.0;
  /* energy layer uses pop animation (grow/fade) instead of bob */
  /* Use explicit shorthand delays so the pop animation has a 4s period and starts immediately */
  animation: energy-pop 4s ease-out 0s infinite, img-glow 3s ease-in-out 0s infinite;
  /* percentage offset keeps the energy nudge proportional to container size */
  --energy-offset: 20%;
}

/* Dramatically delayed duplicate of the energy layer for staggered effect */
.header-energy--delayed{
      z-index: 1;
  opacity: 0.0;
  /* same animations but phase-shifted: energy-pop delayed by 2s (half of 4s) */
  animation: energy-pop 4s ease-out 1s infinite, img-glow 3s ease-in-out 1s infinite;
  --energy-offset: 20%;
  pointer-events: none;
}

/* Third layer: shifted by two-thirds of the 4s cycle (~2.667s) */
.header-energy--delayed2{
      z-index: 2;
  opacity: 0.0;
  animation: energy-pop 4s ease-out 2s infinite, img-glow 3s ease-in-out 2s infinite;
  --energy-offset: 20%;
  pointer-events: none;
}
    /* Fourth layer: shifted by three-quarters of the 4s cycle (3s) */
    .header-energy--delayed3{
      z-index: 3;
      opacity: 0.0;
      animation: energy-pop 4s ease-out 3s infinite, img-glow 3s ease-in-out 3s infinite;
      --energy-offset: 20%;
      pointer-events: none;
    }


.header-actions{
  display:flex;
  flex-direction:column;
  gap:clamp(6px, 1.5vw, 8px);
  align-items:center;
  justify-content:center;
  margin-top:clamp(4px, 1vw, 6px);
  position:relative;
  width:100%;
}

.header-actions .btn{
  padding:clamp(8px, 2vw, 10px) clamp(14px, 3vw, 18px);
  border-radius:var(--radius);
  /* match the card width so buttons visually enclose the card */
  width: var(--header-control-effective);
  max-width:100%;
  display:block;
  margin:0 auto;
}

h1{
  margin: clamp(8px, 2vw, 12px) auto 0 auto;
  /* scale the heading with the header control token so it visually spans the image width */
  font-family: var(--font-display);
  /* Slightly reduced scale to accommodate Orbitron's wider glyphs without wrapping */
  font-size: clamp(12px, calc(var(--header-control-effective) * 0.07), 40px);
  font-weight:600;
  text-align:center;
  /* allow wrapping on narrow screens so text remains centered */
  white-space: normal;
  /* allow descenders (g, y) to render without being clipped */
  overflow: visible;
  /* match the card width exactly so h1 stays centered at all zoom levels */
  width: var(--header-control-effective);
  max-width: 100%;
  box-sizing: border-box;
  /* no horizontal padding - let text-align:center handle centering within the fixed width */
  padding: 0;
  /* slightly increased line-height and bottom padding to avoid clipping descenders */
  line-height:1.15;
  padding-bottom: clamp(4px, 1vw, 6px);
  /* Compact the heading slightly so the new display font doesn't force an extra line-break */
  letter-spacing: 0.1em;
  /* lime outline + pulsating glow */
  /* primary outline for WebKit browsers (reduced thickness) */
  -webkit-text-stroke: 0.25px var(--color-lime-bright);
  /* text-stroke fallback via multiple tiny shadows for other browsers (thinner) */
  text-shadow: -0.6px -0.6px 0 var(--color-lime-bright), 0.6px -0.6px 0 var(--color-lime-bright), -0.6px 0.6px 0 var(--color-lime-bright), 0.6px 0.6px 0 var(--color-lime-bright), 0 0 20px var(--color-lime-bright);
  animation: h1-glow 3s ease-in-out infinite;
}

header h1:first-of-type{
  /* slightly smaller primary header scale to avoid oversized headings */
  font-size: clamp(16px, calc(var(--header-control-effective) * 0.07), 48px);
  /* add extra breathing room under the primary header */
  margin-bottom: clamp(6px, 2vw, 12px);
}

header h2{
  font-size:clamp(16px, 4.5vw, 36px);
  margin:0 auto;
  font-weight:600;
  color:var(--color-teal-primary);
  text-align:center;
  width:100%;
  max-width:var(--header-control-effective);
  box-sizing:border-box;
  line-height:1.2;
}

.p-muted{
  color:var(--color-teal-primary);
  margin:0 0 clamp(6px, 1.5vw, 8px) 0;
  font-size:clamp(0.85rem, 2vw, 0.95rem);
}

.p-muted.small{
  display:block;
  width:100%;
  max-width:var(--header-control-effective);
  margin:clamp(8px, 2vw, 12px) auto 0;
  text-align:center;
  font-size: clamp(11px, 2.5vw, 14px);
  line-height: 1.4;
  padding:0 clamp(8px, 2vw, 12px);
}

.card{
  background:var(--color-lime-bright);
    padding:clamp(25px, 4vw, 35px) clamp(12px, 3vw, 18px) clamp(25px, 3vw, 18px) clamp(12px, 3vw, 18px);
    margin-bottom:clamp(10px, 2.5vw, 16px);
  /* reduce top spacing so the clipboard button sits closer to the headline */
  margin-top: 8px;
  border:none;
  position:relative;
  z-index:1;
  width: var(--header-control-effective);
  max-width: 100%;
  margin-left: auto;
  margin-right: auto;
  max-height: 1200px;
  overflow: visible;
  opacity: 1;
  transform: translateY(0);
  transition: max-height var(--transition-smooth), opacity 420ms ease, transform 420ms ease, padding 420ms ease, margin 420ms ease;
  will-change: transform;
  display:flex;
  flex-direction:column;
  justify-content:center; /* center textarea vertically between the anchored buttons */
  align-items:stretch;
  gap: clamp(10px, 2vw, 14px);
  /* steady glow to match header/controls (no pulsation) */
  box-shadow: 0 0 72px var(--glow-strong-teal), 0 0 40px var(--glow-strong);
}

textarea{
  width:100%;
  min-height:clamp(140px, 30vw, 220px);
  max-height:clamp(50vh, 70vh, 80vh);
  /* symmetric vertical / horizontal padding to avoid visual horizontal shift on narrow screens */
  padding: 0;
  margin-top: 10px;
  margin-left: clamp(2px, 0vw, 5px);
    border:none;
    background:var(--color-lime-bright);
    color:var(--color-teal-primary);
    /* Prefer Space Grotesk (variable) for textarea content; fallback stack kept in --font-mono */
    font-family: var(--font-mono);
    font-variant-numeric: tabular-nums;
  font-size:clamp(11px, 2vw, 13px);
  resize:none;
  white-space:pre-wrap;
  word-break:break-word;
  overflow:auto;
  overflow-wrap: anywhere;
  /* hide visible scrollbars but keep scrolling functional */
  -ms-overflow-style: none; /* IE/Edge */
  scrollbar-width: none; /* Firefox */
}

textarea:focus{
  outline:none;
  box-shadow:none;
}

/* hide webkit scrollbar */
textarea::-webkit-scrollbar{ width:0; height:0; }

.btn{
  background: var(--color-teal-primary);
  color: var(--color-lime-bright);
  padding:clamp(8px, 2vw, 10px) clamp(12px, 2.5vw, 14px);
  border-radius:var(--radius);
  border:none;
  font-weight:600;
  font-size:clamp(0.85rem, 2vw, 1rem);
  cursor:pointer;
  transition:transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast);
  box-shadow:none;
}

/* Shared display/align properties for anchored buttons to avoid duplication */
.btn, .btn-clipboard, #mode-info-btn{
  display: inline-flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  border-radius: var(--radius);
  box-sizing: border-box;
  transform-origin: center;
  will-change: transform;
  /* anchor transform used by shared keyframes; default is no translate */
  --anchor: translateY(0);
  transform: var(--anchor);
}

.btn:hover{
  transform: var(--anchor) scale(1.02);
  box-shadow: 0 10px 28px var(--glow-subtle), 0 0 20px var(--glow-mid);
}

.btn:focus{
  /* remove the visible blue outline on mouse/click focus to match clipboard button */
  outline: none;
}

/* keep an accessible focus indicator for keyboard users */
.btn:focus-visible{
  /* per request: no outline even for focus-visible */
  outline: none;
}

/* provide a brief click/press animation so share/info buttons respond visually */
.btn:active{
  animation: btn-press 220ms ease-out;
}

/* Info button positioned inside .card so its center aligns with the card's bottom edge */
#mode-info-btn{
  position: absolute;
  left: 0;
  top: 100%;
  /* anchor the info button at the card bottom */
  --anchor: translateY(-50%);
  transform: var(--anchor);
  z-index: 30;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  /* center text content inside the anchored button across sizes/lines */
  display: inline-flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  white-space: normal;
  box-shadow: 0 8px 18px var(--glow-subtle), 0 0 10px var(--glow-mid);

  /* Use display font variable for Info / Back labels so they visually match the clipboard button */
  font-family: var(--font-display);
  font-weight: 600;
  font-size: clamp(0.78rem, 2.4vw, 0.98rem);
  letter-spacing: 0.06em;
}

.btn[disabled],.btn:disabled,button[disabled],button:disabled{
  cursor:not-allowed;
  pointer-events:none;
  color:rgba(255,255,255,0.85);
}

.btn.success{
  background:var(--color-teal-primary);
  color:white;
  border:none;
  transform-origin:center;
  animation:btn-pulse 360ms ease-out 1;
}

.btn.error{
  background:var(--color-charcoal-dark);
  color:white;
  border-color:rgba(255,255,255,0.06);
}

/* clipboard button grouped with primary button rules */
.btn-clipboard{
  background: var(--color-teal-primary);
  color: var(--color-lime-bright);
  padding:clamp(12px, 3vw, 16px) clamp(20px, 4vw, 28px);
  font-family: var(--font-display);
  font-weight: 600;
  /* slightly reduced responsive scale + tighter tracking to fit Orbitron without wrapping */
  font-size:clamp(0.6rem, 2.5vw, 0.7rem);
  letter-spacing: 0.1em;
  cursor: pointer;
  /* sizing matches `.header-actions .btn` so it adapts the same on narrow screens */
  width: var(--header-control-effective);
  max-width: 100%;
  box-sizing: border-box;
  display: inline-flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  border-radius:var(--radius);
  border:none;
  /* position the clipboard button so it spans the card and its center aligns with the top edge */
  position: absolute;
  left: 0;
  top: 0;
  /* anchor the clipboard button at the card top */
  --anchor: translateY(-50%);
  transform: var(--anchor);
  z-index: 40;
}

.btn-clipboard.success{
  background: var(--color-lime-bright);
  color: var(--color-teal-primary);
  width: var(--header-control-effective);
  max-width: 100%;
  border:none;
  /* use shared pulse animation which respects the --anchor variable */
  animation: btn-pulse 1000ms ease-out 1, btn-glow 1000ms ease-out 1;
}

.btn-clipboard:hover{
  box-shadow: 0 18px 50px var(--lime-16), 0 6px 18px var(--lime-08);
  transform: var(--anchor) scale(1.02);
}

@keyframes btn-pulse{
  0%,100%{transform:var(--anchor) scale(1);box-shadow:0 6px 18px var(--lime-06)}
  50%{transform:var(--anchor) scale(1.06);box-shadow:0 12px 30px var(--lime-14)}
}

@keyframes btn-glow{
  0%,100%{box-shadow:0 8px 22px var(--lime-10),0 0 0 var(--lime-100)}
  30%{box-shadow:0 26px 72px var(--lime-100),0 0 60px var(--lime-100)}
  60%{box-shadow:0 36px 110px var(--lime-100),0 0 90px var(--lime-100)}
}
 
@keyframes btn-press{
  0%,100%{transform:var(--anchor) scale(1)}
  50%{transform:var(--anchor) scale(1.02)}
}

@keyframes h1-glow{
  0%,100%{text-shadow:-0.6px -0.6px 0 var(--color-lime-bright),0.6px -0.6px 0 var(--color-lime-bright),-0.6px 0.6px 0 var(--color-lime-bright),0.6px 0.6px 0 var(--color-lime-bright),0 0 20px var(--color-lime-bright),0 0 30px var(--lime-40)}
  50%{text-shadow:-0.6px -0.6px 0 var(--color-lime-bright),0.6px -0.6px 0 var(--color-lime-bright),-0.6px 0.6px 0 var(--color-lime-bright),0.6px 0.6px 0 var(--color-lime-bright),0 0 30px var(--color-lime-bright),0 0 50px var(--glow-strong),0 0 70px var(--lime-60)}
}

@keyframes img-glow{
  0%,100%{filter:drop-shadow(0 0 10px var(--color-lime-bright)) drop-shadow(0 0 30px var(--lime-40))}
  50%{filter:drop-shadow(0 0 15px var(--color-lime-bright)) drop-shadow(0 0 50px var(--lime-60))}
}

@keyframes img-bob{
  0%,100%{transform:translateY(var(--bob-offset,0%)) scale(var(--svg-scale,1))}
  50%{transform:translateY(calc(var(--bob-offset,0%) - 6%)) scale(var(--svg-scale,1))}
}

@keyframes energy-pop{
  0%{
    opacity: 1;
    transform: translateY(var(--energy-offset,0%)) scale(0);
  }
  /* Hold fully opaque most of the cycle so pulses remain visible longer */
  85%{
    opacity: 0.2;
    transform: translateY(var(--energy-offset,0%)) scale(1);
  }
  100%{
    opacity: 0;
    transform: translateY(var(--energy-offset,0%)) scale(1);
  }
}

/* Particles: small glowing blobs that slowly float upward */
.particles{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
  z-index:2;
  overflow:visible;
}
.particles .particle{
  position:absolute;
  bottom:0;
  background: radial-gradient(circle at 40% 30%, var(--lime-95) 0%, var(--lime-55) 30%, var(--glow-mid) 60%, rgba(97,196,151,0) 100%);
  border-radius:50%;
  filter: blur(6px);
  opacity:0;
  transform: translateY(0) translateX(0) scale(1);
  will-change: transform, opacity, filter;
  mix-blend-mode: screen;
  transition: opacity 160ms linear;
  animation: particle-up var(--dur, 6s) linear infinite;
}

/* Mini particle system inside the header container (always on top) */
.mini-particles{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
  z-index:10002; /* above crown (10001) */
  overflow:visible;
}
.mini-particles .particle-mini{
  position:absolute;
  /*bottom:8%;*/
  /* use a solid, fully-opaque color for high visibility during testing */
  background: var(--lime-100);
  border-radius:50%;
  /* reduced blur for crisper, more defined mini-particles during testing */
  /*filter: blur(1px);*/
  opacity:1; /* start fully opaque; keyframes will keep them visible until near the end */
  transform: translateY(0) translateX(0) scale(1);
  will-change: transform, opacity, filter;
  mix-blend-mode: screen;
  transition: opacity 120ms linear;
  animation: mini-particle-up var(--dur, 1s) linear infinite;
}

@keyframes mini-particle-up{
  0%{ opacity: 0; transform: translateY(0) translateX(0) scale(0); }
  5%{ opacity: 1; transform: translateY(0) translateX(0) scale(0.5); }
  50%{ opacity: 1; transform: translateY(-2750) translateX(0) scale(1); }
  /* remain fully opaque for the majority of the animation for testing visibility */
  /*95%{ opacity: 1; transform: translateY(-2500%) translateX(0px) scale(0.35); }*/
  100%{ opacity: 0; transform: translateY(-3000%) translateX(0px) scale(0.3); }
}

@keyframes particle-up{
  0%{ opacity: 0; transform: translateY(0) translateX(0) scale(1); }
  8%{ opacity: 1; }
  /* extend the global particles' travel so they float further up the viewport */
  100%{ opacity: 0; transform: translateY(-1280vh) translateX(var(--drift, 0px)) scale(0.6); }
}

@media (prefers-reduced-motion: reduce){
  .particles .particle{ animation: none !important; opacity: 0 !important; }
}

@media (prefers-reduced-motion: reduce){
  .header-crown, .header-energy, h1, .card{ animation: none !important; }
}

.header-actions, .card {
  min-width: 0;
  max-width: 100%;
}
/* small-screen media queries removed — layout relies on clamp() and tokens */
/* Ensure anchored buttons keep their centering translate while hovered/active */
#mode-info-btn:hover, .btn-clipboard:hover{
  transform: var(--anchor) scale(1.02);
  box-shadow: 0 10px 28px var(--glow-subtle), 0 0 20px var(--glow-mid);
}

/* Use shared press animation which respects the --anchor variable */
#mode-info-btn:active, .btn-clipboard:active{
  animation: btn-press 220ms ease-out;
}
</style>
</head>
<body>
  <div class="particles" aria-hidden="true"></div>

<header>
  <div class="header-svg-container">
    <img src="./mighty_crown_go.svg" alt="Pokémark" class="header-crown" />
    <img src="./mighty_energy_go.svg" alt="" class="header-energy" aria-hidden="true" />
    <img src="./mighty_energy_go.svg" alt="" class="header-energy header-energy--delayed" aria-hidden="true" />
    <img src="./mighty_energy_go.svg" alt="" class="header-energy header-energy--delayed2" aria-hidden="true" />
    <img src="./mighty_energy_go.svg" alt="" class="header-energy header-energy--delayed3" aria-hidden="true" />
    <div class="mini-particles" aria-hidden="true"></div>
  </div>
  <h1>MÄCHTIGE POKÉMON</h1>
  <div class="header-actions">
    <div class="card">
      <button class="btn-clipboard">MÄCHTIGER SUCHSTRING</button>
      <textarea id="output" readonly></textarea>
      <button id="mode-info-btn" class="btn">INFO</button>
    </div>
  </div>
</header>

<script>
// Pokemon groups
const G1='018,076,130,405,545,596,697,748,003,062,149,160,466,473,604,691';
const G2='40,248,303,359,623,858,862,908,210,229,282,430,445,452,461,480-482';
const FORMS=['110,38,78','110,38,galar','110,alola,78','110,alola,galar','galar,38,78','galar,38','galar,alola,78','galar,alola'];

function generateTemplate(r24,r25){
  const base=FORMS.map(f=>`${G1},${G2},${f}`).join('&');
  const with24=FORMS.map(f=>`${r24},${G2},${f}`).join('&');
  return `${base}&${G1},${r25}&${with24}&${r24},${r25}`;
}

const EVENT24_START = new Date(Date.UTC(2024, 10, 23, 0, 0, 0));
const EVENT24_END   = new Date(Date.UTC(2024, 10, 24, 23, 59, 59));

const EVENT25_START = new Date(Date.UTC(2025, 10, 15, 0, 0, 0));
const EVENT25_END   = new Date(Date.UTC(2025, 10, 16, 23, 59, 59));

const output = document.getElementById('output');
const infoBtn = document.getElementById('mode-info-btn');

// Small audio factory to preload and play short nav sounds (restartable)
function createAudio(src, vol = 0.2){
  const a = new Audio(src);
  a.preload = 'auto';
  a.volume = vol;
  return {
    play(){
      try{ a.pause(); a.currentTime = 0; a.play().catch(()=>{}); }catch(e){}
    }
  };
}

const _copyNav = createAudio('./copy_nav.opus', 0.2);
const _infoNav = createAudio('./info_nav.opus', 0.2);
const _backNav = createAudio('./back_nav.opus', 0.2);

function playCopyNavSound(){ _copyNav.play(); }
function playInfoNavSound(){ _infoNav.play(); }
function playBackNavSound(){ _backNav.play(); }

// Create a few gentle glowing particles that float upwards in the header
function initParticles(count = 12){
  try{
    const container = document.querySelector('.particles');
    if(!container) return;
    container.innerHTML = '';
    for(let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      // Randomize horizontal position across the page width
      const left = Math.round(Math.random()*100);
      // start near the bottom area (0% - 10%) so particles originate from the bottom
      const bottom = Math.random()*10; 
      const size = (Math.random()*22)+8; // 8px - 30px
      const dur = (Math.random()*8)+6; // 6s - 14s
      const delay = Math.random()*-10; // negative so some start midway
      const drift = (Math.random()*240 - 120) + 'px';
      p.style.left = left + '%';
      p.style.bottom = bottom + '%';
      p.style.width = size + 'px';
      p.style.height = size + 'px';
      p.style.setProperty('--dur', dur + 's');
      p.style.setProperty('--drift', drift);
      p.style.setProperty('animation-delay', delay + 's');
      container.appendChild(p);
    }
  }catch(e){/* ignore */}
}

// Mini particle system inside the header container (faster, smaller, always-on-top)
function initMiniParticles(count = 10){
  try{
    // Prefer the mini-particles placed inside the header SVG container so
    // they visually originate from the crown/energy area.
    const container = document.querySelector('.header-svg-container .mini-particles') || document.querySelector('.mini-particles');
    if(!container) return;
    container.innerHTML = '';
    const rect = container.getBoundingClientRect();
    // find an energy layer to align spawn to its visual center if present
    const crownEl = document.querySelector('.header-svg-container .header-crown') || document.querySelector('.header-crown');
    const energyEl = document.querySelector('.header-svg-container .header-energy') || document.querySelector('.header-energy');
    // default spawn center in pixels (relative to container)
    // We'll compute spawn coordinates based on the crown if present, otherwise energy, otherwise container center.
    const spawnDownRatio = -0.25; // fraction of container height to push spawn slightly downward
    // extra pixel nudge (fraction of container height) to push spawn a bit lower
    const spawnNudgePx = rect.height * 0.1; // 6% of container height
    let spawnCenterX = rect.width * 0.5;
    let spawnCenterYfromTop = rect.height * 0.45 + rect.height * spawnDownRatio + spawnNudgePx; // px from top

    if(crownEl){
      const cRect = crownEl.getBoundingClientRect();
      // use crown bottom center as the base spawn point
      const crownCenterX = cRect.left + cRect.width * 0.5;
      const crownBottomY = cRect.top + cRect.height;
      spawnCenterX = crownCenterX - rect.left;
      spawnCenterYfromTop = (crownBottomY - rect.top) + rect.height * (spawnDownRatio * 0.5) + spawnNudgePx;
    } else if(energyEl){
      const eRect = energyEl.getBoundingClientRect();
      const energyCenterX = eRect.left + eRect.width * 0.5;
      const energyBottomY = eRect.top + eRect.height;
      spawnCenterX = energyCenterX - rect.left;
      spawnCenterYfromTop = (energyBottomY - rect.top) + rect.height * (spawnDownRatio * 0.5) + spawnNudgePx;
    }

    // Wider spawn area around the selected base point (crown/energy/container)
    const horizontalSpread = Math.max(120, rect.width * 0.6); // px
    const verticalSpread = Math.max(40, rect.height * 0.45); // px
    for(let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle-mini';
      // pick a point in a wider box around the base point with jitter
      const jitterX = (Math.random() * 60) - 30; // -30px .. +30px
      const jitterY = (Math.random() * 48) - 24; // -24px .. +24px

      const leftPx = spawnCenterX + (Math.random() - 0.5) * horizontalSpread + jitterX;
      const topPx = spawnCenterYfromTop + (Math.random() - 0.5) * verticalSpread + jitterY;
      const leftPct = rect.width > 0 ? (leftPx / rect.width) * 100 : 50;
      const topPct = rect.height > 0 ? (topPx / rect.height) * 100 : 30;

      // Uniform appearance: size and duration fixed so only spawn position varies
      const size = 8; // uniform size in px
      const dur = 0.28; // uniform duration in seconds
      // randomize spawn timing: negative values start mid-animation
      const delay = (Math.random() * 0.6) - 0.3; // -0.3s .. +0.3s
      const drift = '0px';

      p.style.left = leftPct + '%';
      p.style.top = topPct + '%';
      p.style.width = size + 'px';
      p.style.height = size + 'px';
      p.style.filter = 'blur(4px)';
      p.style.setProperty('--dur', dur + 's');
      p.style.setProperty('--drift', drift);
      p.style.setProperty('animation-delay', delay + 's');

      // On each animation iteration reposition the particle to a new random
      // point around the same spawn center and give it a slight random delay
      // so particles don't sync across respawns.
      const reposition = () => {
        try{
          const r = container.getBoundingClientRect();
          const xPx = spawnCenterX + (Math.random() - 0.5) * horizontalSpread + (Math.random() * 60 - 30);
          const yPx = spawnCenterYfromTop + (Math.random() - 0.5) * verticalSpread + (Math.random() * 48 - 24) + spawnNudgePx;
          const xPct = r.width > 0 ? (xPx / r.width) * 100 : 50;
          const yPct = r.height > 0 ? (yPx / r.height) * 100 : 30;
          p.style.left = Math.min(100, Math.max(0, xPct)).toFixed(4) + '%';
          p.style.top = Math.min(100, Math.max(0, yPct)).toFixed(4) + '%';
          // small random delay so particles respawn with slight phase differences
          p.style.setProperty('animation-delay', ((Math.random() * 0.6) - 0.3) + 's');
        }catch(e){/* ignore */}
      };
      p.addEventListener('animationiteration', reposition);

      container.appendChild(p);
    }
  }catch(e){/* ignore */}
}

// NOTE: no global busy flag — button animations are reset on each click so
// rapid clicks are allowed while the visual success state is kept until
// the last timeout completes.

/* Info text previously shown in the popover — now generated so it can include live ranges */
function getInfoText(){
  const { range24, range25 } = buildRanges();
  return `VERWENDUNG

Kopiere den Suchstring aus dem Textfeld oder drücke den großen Knop darüber, um ihn in deine Zwischenablage zu speichern. Füge den Suchstring dann in die Pokémon GO Suchleiste ein, um alle mächtigen Pokémon in deinem Besitz zu finden.


EINSCHRÄNKUNGEN

Die Suchleiste von Pokémon GO erlaubt nur einfache AND‑Verknüpfungen (&) und unterstützt weder Klammern noch OR‑Logik (|). Jede Kombination aus Pokémon, Form und Fangalter muss einzeln aufgeführt werden.


DETAILS

Disjunktive Normalform
Jede gültige Kombination wird einzeln gelistet.

Automatischer Altersfilter
Die Zeiträume werden dynamisch berechnet.


EVENT INTEL

Naturzone 23.–24.11.2024
` + range24 + `

#003 Bisaflor
#018 Tauboss
#062 Quappo
#076 Geowaz
#130 Garados
#149 Dragoran
#160 Impergator
#405 Luxtra
#466 Elevoltek
#473 Mamutel
#545 Cerapendra
#596 Voltula
#604 Zapplarang
#697 Monargoras
#748 Aggrostella

Naturzone 15.–16.11.2025
` + range25 + `

#040 Knuddeluff
#078 Galar-Galoppa
#110 Galar-Smogmog
#038 Alola-Vulnona
#248 Despotar
#303 Flunkifer
#359 Absol
#623 Golurk
#858 Silembrim
#862 Barrikadax
#908 Maskagato
#210 Granbull
#229 Hundemon
#282 Guardevoir
#430 Kramshef
#445 Knakrack
#452 Toxiquak
#461 Snibunna
#480 Selfe
#481 Vesprit
#482 Tobutz
`;
}

function daysSince(date){
  const msPerDay = 1000*60*60*24;
  return Math.floor((Date.now() - date.getTime())/msPerDay);
}

function buildRanges(){
  const min24 = daysSince(EVENT24_END);
  const max24 = daysSince(EVENT24_START);
  const r24 = `alter${min24}-${max24}`;
  const min25 = daysSince(EVENT25_END);
  const max25 = daysSince(EVENT25_START);
  const r25 = `alter${min25}-${max25}`;
  return { range24: r24, range25: r25 };
}

function generateFinalString(){
  const { range24, range25 } = buildRanges();
  return generateTemplate(range24,range25)
    .split('&').map(g => g.trim().replace(/,+/g, ',').replace(/^,|,$/g, ''))
    .filter(g => g.length > 0).join('&').replace(/\s+/g, ' ');
}

let cachedString = '';
let _prevCachedString;

function renderPreview(){
  if(!output) return;
  cachedString = generateFinalString();
  output.value = cachedString;
  // if info was shown in the textarea, close that state and update the Info button label
  try{
    if(infoBtn && infoBtn.getAttribute('data-info-open') === 'true'){
      infoBtn.setAttribute('data-info-open','false');
      infoBtn.innerText = 'Info';
    }
  }catch(e){}
  requestAnimationFrame(() => { if(output) output.scrollTop = 0; });
  // After rendering new content recompute whether the body should be centered
  requestAnimationFrame(updateBodyCentered);
}

let timer;

function scheduleMidnightUpdate(){
  if(timer) clearTimeout(timer);
  const now = new Date();
  const next = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0, 0);
  const ms = next.getTime() - now.getTime();
  timer = setTimeout(()=>{
    renderPreview();
    scheduleMidnightUpdate();
  }, ms + 1000);
}

// Toggle body centering when the document content height is <= viewport height.
function updateBodyCentered(){
  try{
    const docHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
    const viewH = window.innerHeight || document.documentElement.clientHeight;
    if(docHeight <= viewH + 1){
      document.body.classList.add('centered');
    } else {
      document.body.classList.remove('centered');
    }
  }catch(e){}
}

// Update centering on resize/orientation changes and when visibility changes
window.addEventListener('resize', updateBodyCentered);
window.addEventListener('orientationchange', updateBodyCentered);
document.addEventListener('visibilitychange', ()=>{ !document.hidden && updateBodyCentered(); });

function toggleModeInfo(){
  if(!infoBtn || !output) return;
  const isOpen = infoBtn.getAttribute('data-info-open') === 'true';

  if(!isOpen){
    _prevCachedString = cachedString;
    const info = getInfoText();
    cachedString = info;
    output.value = info;
    requestAnimationFrame(()=>{ if(output) output.scrollTop = 0; });
    infoBtn.setAttribute('data-info-open', 'true');
    infoBtn.innerText = 'ZURÜCK';
    // content changed to info view — recompute centering
    requestAnimationFrame(updateBodyCentered);
  } else {
    infoBtn.setAttribute('data-info-open', 'false');
    infoBtn.innerText = 'INFO';
    if(_prevCachedString){
      cachedString = _prevCachedString;
      _prevCachedString = undefined;
      output.value = cachedString;
      requestAnimationFrame(()=>{ if(output) output.scrollTop = 0; });
      // content restored — recompute centering
      requestAnimationFrame(updateBodyCentered);
    } else {
      renderPreview();
    }
  }
}

function _setButtonState(btn, text, state){
  if(!btn) return;
  if(btn._timeout) clearTimeout(btn._timeout);
  if(!btn._origText) btn._origText = btn.innerText;
  // we don't change or rely on `disabled` here — allow repeated clicks.

  // preserve the button's current layout size so short temporary labels (like "✓")
  // don't cause the button to shrink. Store existing inline minHeight to restore later.
  try{
    if(!btn._savedMinHeight){
      btn._savedMinHeight = btn.style.minHeight || '';
      const rect = btn.getBoundingClientRect();
      if(rect && rect.height){
        btn.style.minHeight = rect.height + 'px';
      }
    }
  }catch(e){}

  // Update label and restart the visual animation for the requested state.
  btn.innerText = text;
  // remove any previous state classes first
  btn.classList.remove('success','error');
  if(state){
    // force-animation-restart: clear inline animation, force reflow, then add class
    btn.style.animation = 'none';
    // read a layout property to flush style changes
    void btn.offsetWidth;
    btn.classList.add(state);
    // allow future CSS animations to run normally
    btn.style.animation = '';
  }
  
  const ms = btn.classList.contains('btn-clipboard') ? 1000 : 360;
  btn._timeout = setTimeout(()=>{
    // restore original text and any preserved minHeight
    btn.innerText = btn._origText;
    btn.classList.remove('success','error');
    try{
      if(btn._savedMinHeight !== undefined){
        btn.style.minHeight = btn._savedMinHeight || '';
        delete btn._savedMinHeight;
      }
    }catch(e){}
    delete btn._timeout;
  }, ms);
}

function copyAndNotify(btn){
  const button = btn || document.querySelector('.btn-clipboard');
  navigator.clipboard.writeText(cachedString || generateFinalString()).then(()=>{
    renderPreview();
    _setButtonState(button, '✓', 'success');
  }, ()=>{
    _setButtonState(button, 'Kopieren fehlgeschlagen', 'error');
  });
}

// Attach event listeners instead of using inline onclick attributes. Listeners
// check `uiBusy` and will ignore clicks while busy.
const _attachUIListeners = ()=>{
  const clipboardEl = document.querySelector('.btn-clipboard');
  if(clipboardEl){
    clipboardEl.addEventListener('click', (e)=>{
      playCopyNavSound();
      copyAndNotify(clipboardEl);
    });
  }
    if(infoBtn){
    infoBtn.addEventListener('click', (e)=>{
      // if Info view is currently open, play the back sound; otherwise play the info-open sound
      const isOpenNow = infoBtn.getAttribute('data-info-open') === 'true';
      if(isOpenNow){
        playBackNavSound();
      } else {
        playInfoNavSound();
      }
      toggleModeInfo();
    });
  }
};

_attachUIListeners();


renderPreview();
scheduleMidnightUpdate();
// initialize particles after rendering so header sizes are known
initParticles(12);
// initialize mini particles (inside header) after main particles
initMiniParticles(10);
// Recreate particles on resize (debounced) so positions remain distributed
let _particleResizeTimer;
window.addEventListener('resize', ()=>{
  if(_particleResizeTimer) clearTimeout(_particleResizeTimer);
  _particleResizeTimer = setTimeout(()=>{
    initParticles(12);
    initMiniParticles(10);
  }, 200);
});

document.addEventListener('visibilitychange', ()=>{ !document.hidden && (renderPreview(), scheduleMidnightUpdate()); });

// Ensure energy layers that just started their pulse are visually on top.
// Listen for animationstart/animationiteration for the `energy-pop` animation
// and temporarily bump the element's inline z-index, then restore it.
(function(){
  function parseFirstDuration(str){
    if(!str) return 4;
    const first = (str.split(',')[0]||'4s').trim();
    // allow values like "1.5s" or "200ms"
    if(first.endsWith('ms')) return parseFloat(first) / 1000 || 4;
    return parseFloat(first) || 4;
  }

  function makeBumper(el){
    const cs = getComputedStyle(el);
    const dur = parseFirstDuration(cs.animationDuration);
    // store original z (computed) so we can restore; if 'auto' use empty string
    const baseZ = cs.zIndex === 'auto' ? '' : cs.zIndex;
    el.dataset._baseZ = baseZ;
    const resetDelay = Math.max(200, dur * 1000 * 0.5);
    const bump = ()=>{
      if(el._zResetTimeout) clearTimeout(el._zResetTimeout);
      el.style.zIndex = 10000;
      el._zResetTimeout = setTimeout(()=>{
        if(el.dataset._baseZ === '') el.style.zIndex = '';
        else el.style.zIndex = el.dataset._baseZ;
        delete el._zResetTimeout;
      }, resetDelay);
    };
    el.addEventListener('animationstart', (ev)=>{ if(ev.animationName === 'energy-pop') bump(); });
    el.addEventListener('animationiteration', (ev)=>{ if(ev.animationName === 'energy-pop') bump(); });
  }

  // run on DOMContentLoaded to ensure elements exist
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{
      document.querySelectorAll('.header-energy').forEach(makeBumper);
    });
  } else {
    document.querySelectorAll('.header-energy').forEach(makeBumper);
  }
})();
</script>

</body>
</html>
